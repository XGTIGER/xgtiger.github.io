{"pages":[{"url":"ru-he-zai-da-gui-mo-shu-ju-ku-guan-li-zhong-shi-yong-ansible.html","text":"介绍 Ansible ,现在不只是一个配置管理和应用部署工具，2.2版本更是增加了对 编排 的支持,2.0版本经过了代码的完全重构，全面支持可扩展的插件系统，便于使用者通过实现各种功能插件来满足自己的需求。Ansible 的作者Michael DeHaan 同时也是知名软件 Cobbler 与 Func 的作者。 Ansible的模块设计,遵循 幂等性 的原则,在使用playbook的过程中，你将更清晰的体会到这一特点。 Ansible 的常被用于如下（但不限于）几个场景： 自动化部署应用 自动化配置管理 自动化的持续交付 同类的框架工具有老牌的Chef,Puppet,Saltstack等，Ansible 默认通过 SSH 协议（可扩展，比如DOCKER的连接器），能做到agentless，即 Ansible 没有类似saltstack的agent部署需求，相对灵活简便;缺点也存在，比如执行响应的开销相对大.其实没那么明显，与您常用的ssh指令相当，而且Ansible可使用扩展(如ZeroMQ）来提升执行效率。 同类工具系统简单的对比： 框架名称 Ansible Saltstack Puppet 开发语言 Python Python Ruby 是否有客户端 无 有 有 服务器与远程机器是否相互验证 是 是 是 服务器与远程机器通信是否加密 是，使用 OpenSSH 是，使用 AES 加密 是，标准 SSL 协议 平台支持 支持 AIX、BSD、 HP-UX、 Linux、Mac OSX、Solaris 支持 BSD、Linux、Mac OS X、Solaris、 Windows 支持 AIX、BSD、HP-UX、Linux、 MacOSX、Solaris、 Windows 配置文件格式 YAML YAML Ruby 语法格式 命令行执行 支持 支持 不支持，但可通过配置模块实现 值得注意的是，Ansible2.0版本后，增强了对WINDOWS服务器的管理支持，但自身依然不支持以WIN主机作管理节点。 本文通过若干范例,介绍下如何在大规模的数据库集群管理中使用Ansible.现在只需要将 Ansible部署于一台管理节点（在Docker上运行是没问题的，官方 镜像 )，便可开始Ansible探索之旅 。 重要概念 Inventory :即Ansible使用的主机清单。如还没有概念,可参考我的另一篇 《基本使用》 来快速熟悉下. Playbook :ansible的主要工作形式,可参考我的几篇 《Playbook简介》 快速熟悉下. Module :ansible的功能基本单元,数量一直在不断增长,目前官方收入的均由python语言编写,但其实可由任何语言完成.所有的模块列表请见 这里 . 基本的MYSQL管理模块 mysql_user:管理用户及授权 host_all : 是不是对该名字的所有的主机进行操作,但不能在创建用户时使用 priv : *.*:SELECT的形式 #去除所有匿名用户 - mysql_user: name: '' host_all: yes state: absent #创建具备所有库权限的用户bob,密码12345或使用mysql的HASH形式 - mysql_user: name: bob password: 12345 priv: '*.*:ALL' state: present - mysql_user: name: bob password: '*EE0D72C1085C46C5278932678FBE2C6A782821B4' encrypted: yes priv: '*.*:ALL' state: present #范例:移除所有名为sally用户 - mysql_user: name: sally host_all: yes state: absent mysql_db: 管理数据库的创建/移除/备份/导入 #创建一个数据库 - name: Create a new database with name 'bobdata' mysql_db: name: bobdata state: present #逻辑备份所有数据 - name: Dump all databases to hostname.sql mysql_db: state: dump name: all target: /tmp/ {{ inventory_hostname }} .sql #导入SQL脚本 - name: Import file.sql similar to mysql -u <username> -p <password> < hostname.sql mysql_db: state: import name: all target: /tmp/ {{ inventory_hostname }} .sql mysql_variables: 管理运行中MYSQL的全局变量,如果有重启复制线程的需求,配合mysql_replication可实现 #管理MYSQL的变量,根据需要可控是否重启复制线程 --- - hosts: all vars: restart_replication: \" {{ restart_repl | default ( 'no' ) }} \" vars_prompt: - name: \"login_password\" prompt: \"mysql login password\" tasks: - name: stop slave when needed mysql_replication: login_host: \" {{ login_host | default ( '127.0.0.1' ) }} \" login_port: \" {{ login_port | default ( 3358 ) }} \" login_user: \" {{ login_user | default ( 'root' ) }} \" login_password: \" {{ login_password }} \" mode: \"stopslave\" when: restart_replication =='yes' - name: manage mysql variables mysql_variables: login_host: \" {{ login_host | default ( '127.0.0.1' ) }} \" login_port: \" {{ login_port | default ( 3358 ) }} \" login_user: \" {{ login_user | default ( 'root' ) }} \" login_password: \" {{ login_password }} \" variable: \" {{ variable }} \" value: \" {{ value }} \" - name: start slave when needed mysql_replication: login_host: \" {{ login_host | default ( '127.0.0.1' ) }} \" login_port: \" {{ login_port | default ( 3358 ) }} \" login_user: \" {{ login_user | default ( 'root' ) }} \" login_password: \" {{ login_password }} \" mode: \"startslave\" when: restart_replication == 'yes' mysql_replication: 管理主从复制,开启/停止复制线程/获取复制信息等等 # 停止复制线程 - mysql_replication: mode: stopslave # 获取主库的复制坐标 - mysql_replication: mode: getmaster # change master - mysql_replication: mode: changemaster master_host: 192.0.2.1 master_log_file: mysql-bin.000009 master_log_pos: 4578 # 检查ansible.example.com的复制状态 - mysql_replication: mode: getslave login_host: ansible.example.com login_port: 3308 编写role和playbook实现自定义功能 playbook和role才是使用ansible的正确姿势，参考 Role的使用 这里通过编写一个role来完成一个通用的mysql的部署功能: 目录结构如下: mysql_install ├── defaults │ └── main.yml ├── files │ └── install.sh ├── handlers │ └── main.yml ├── meta │ └── main.yml ├── README.md ├── tasks │ ├── generate_mysqld_script.yml │ ├── init.yml │ ├── main.yml │ ├── setup_Debian.yml │ ├── setup_from_source.yml │ └── setup_RedHat.yml ├── templates │ ├── my5.5.cnf.j2 │ ├── my.cnf.j2 │ └── mysqld.j2 └── vars ├── Debian.yml ├── From_source.yml ├── main.yml └── Redhat.ym 我们着重关注task部分,因为这是主要的功能实现部分. 入口是main.yml,基本逻辑是: 1.如果不使用源码安装,则根据目标OS的类型从其对应源另安装,这里使用了 include ,使用结构更清晰: #setup a mysqld --- - name: Include OS-specific variables. include_vars: \" {{ ansible_os_family }} .yml\" when: not mysql_install_from_source - include: setup_from_source.yml when: mysql_install_from_source and do_install - include: setup_RedHat.yml when: not mysql_install_from_source and ansible_os_family == 'RedHat' and do_ install - include: setup_Debian.yml when: not mysql_install_from_source and ansible_os_family == 'Debian' and do_ install - include: init.yml 这里我们只看在REDHAT系统的安装过程,这里首先检查是否已经安装过了MYSQL,只有否才会进行安装及初始化数据目录: --- - name: INSTALL ON REDHAT | Check if MySQL is already installed. stat: path=/etc/init.d/mysqld register: mysql_installed - name: INSTALL ON REDHAT | add mysql repo from mysql.com yum: name: \"http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm\" state: present when: mysql_installed.stat.exists == false - name: INSTALL ON REDHAT | ensure MySQL packages are installed yum: name: \" {{ item }} \" state: installed with_items: \" {{ mysql_packages }} \" - name: INSTALL ON REDHAT | init datadir shell: \"mysql_install_db --user= {{ mysql_user }} --datadir= {{ mysql_datadir }} \" when: mysql_installed.stat.exists == false 然后,无论是什么系统类型,task流程都会走到init这里.做了几件事: 生成mysqld 服务控制脚本 生成服务配置 启动mysql服务 清理匿名用户 为root用户设置密码 使服务开机启动 当然可以做的更详细,这里为了演示. # init a mysql instance --- - name: generate mysqld script template: src: mysqld.j2 dest: \" {{ mysql_initd }} / {{ mysql_daemon }} \" owner: root group: root mode: 0744 backup: yes tags: generate_mysqld_script - name: Copy my.cnf template: src: my.cnf.j2 dest: \" {{ mysql_conf_file }} \" owner: root group: root mode: 644 notify: restart mysql - name: make mysqld started service: name: \" {{ mysql_daemon }} \" state: started - name: Delete anonymous user. mysql_user: name: \"\" state: absent login_user: \" {{ mysql_root_username }} \" login_password: \" {{ mysql_root_password }} \" check_implicit_admin: true - name: set MySQL root password for all hosts. mysql_user: name: root password: \" {{ mysql_root_password }} \" login_user: \" {{ mysql_root_username }} \" login_password: \"\" check_implicit_admin: true host_all: yes - name: enable mysql daemon on os start service: name: \" {{ mysql_daemon }} \" enabled: \" {{ mysql_daemon_enabled_on_os_start }} \" 注意这里生成服务配置文件时,如果目标文件内容有所改变,这里将会触发\"重启服务\"的操作,具体有handler处理: #handlers/main.yml --- - name: restart mysql service: \"name= {{ mysql_daemon }} state=restarted\" when: mysql_restart_daemon 并且配置文件的内容来自role的默认配置defaults/main.yml. 假设有下面这样一个playbook: --- - name: install mysql on all nodes hosts: - all remote_user: root gather_facts: True roles: - { role: mysql_install} 执行 ansible-playbook -i hosts.ivt site.yml 如果没有异常的出现,所有目标主机将达到一致的状态. 自定义的执行模块 前文说到ansible是全面支持插件系统的,如模块、callback、connections、lookup等等.ANSIBLE自带的模块虽然已经非常强大,但有时仍不能覆盖某些场景,比如我就想实现在数据库的查询,这里我实现了一个简单的执行Module,由于并未全面对mysql的各种语句作过测试,所以使用场景目前还是有限. 先看下文档: > MYSQL_EXECUTE execute a SQL query in MySQL database. Options (= is mandatory): - auto_get_master `yes' will detect the master node and execute execute query on master,if execute_on_master is \"yes\" in replication situation. `no' will exit with an error:this host is not master node. (Choices: yes, false) [Default: False] - config_file Specify a config file from which user and password are to be read [Default: ~/.my.cnf] - connect_timeout The connection timeout when connecting to the MySQL server. [Default: 30] - dict_reault whether the result data should be dict type in json format [Default: False] - execute_on_master `yes' will execute the query on the master node if in replication situation. (Choices: yes, false) [Default: False] - filter_columns filter the specified column(s)(,seperated) to the result data [Default: all] - login_host Host running the database [Default: localhost] - login_password The password used to authenticate with [Default: None] - login_port Port of the MySQL server. Requires login_host be defined as other then localhost if login_port is used [Default: 3306] - login_unix_socket The path to a Unix domain socket for local connections [Default: None] - login_user The username used to authenticate with [Default: None] = query a SQL query in MySQL database - ssl_ca The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server. [Default: None] - ssl_cert The path to a client public key certificate. [Default: None] - ssl_key The path to the client private key. [Default: None] Notes: Execute a query on mysql server.For some dml,generally must be executed on the master node. Requires the MySQLdb Python package on the remote host. For Ubuntu, this is as easy as apt-get install python-mysqldb. (See [apt].) For CentOS/Fedora, this is as easy as yum install MySQL-python. (See [yum].) Both `login_password' and `login_user' are required when you are passing credentials. If none are present, the module will attempt to read the credentials from `~/.my.cnf', and finally fall back to using the MySQL default login of 'root' with no password. Requirements: MySQLdb 这里我设定了两个有用的参数 auto_get_master: 自动找到复制集群的主库 execute_on_master :语句仅允许在主库上被执行,目的是防止破坏集群的正常复制. 使用范例: mysql_execute: login_port: 3358 login_password: pass login_user: monitor login_host: \" {{ inventory_hostname }} \" query: \"show master status\" execute_on_master: yes auto_get_master: yes 如果有兴趣研究源码请到这里 执行效率 据我的经验,如修改用户授权开30个并发对10000+实例的进行操作,基本能在20分钟内完成,操作效率相对还是很高的,对较小规模的集群可以做到\"分分钟\"搞定. 总结 Ansible带来了一种简洁、高效、灵活的方式来完成那些如果使用传统方式通常比较复杂(也意味着更多的出错机会)的工作，很多场景确实有事半功倍效果。 通过这些经验案例,希望能抛砖引玉,大家再举一反三,欢迎与我讨论。","tags":"Ansible","title":"如何在大规模数据库管理中使用ANSIBLE"},{"url":"ansible-kuai-su-shang-shou-role.html","text":"让ansible 工作的真正的姿势,还是使用 role 简单来说,role的组织类似pypi,是ansible的功能包. ansible有类似dockerhub的东东:ansible-galaxy ,你可以安装某人发布的role : ansible-galaxy install username.rolename 或开始创建一个新的role: ansible-galaxy init testrole 这样名称为 testrole 的role就初始化好了,看看它的结构: ├── defaults │ └── main.yml ├── files ├── handlers │ └── main.yml ├── meta │ └── main.yml ├── README.md ├── tasks │ └── main.yml ├── templates ├── tests │ ├── inventory │ └── test.yml └── vars └── main.yml defaults:简单说就是可以配置默认值的位置. files: 可以将你在项目中使用的任何文件,比如自定的脚本(远程)/安装包等等,放在这里,注意在使用这个文件时,你不需要指明路径,ansible自动处理 handlers: 意义和playbook中的意义相同 meta: 可定义作者/版本/依赖等信息 vars: 定义变量.这里有个小问题,defaults中同样可以定义变量,那么变量的优先级是怎样的?如果task中也存在相同变量呢?playbook命令行中又传入一个相同的呢? 很简单 优先级 命令行(-e) > task vars > role vars > role defaults 直接来一个demo: meta: --- galaxy_info: author: your name description: company: your company ( optional ) # Some suggested licenses: # - BSD (default) # - MIT # - GPLv2 # - GPLv3 # - Apache # - CC-BY license: license ( GPLv2 , CC-BY , etc ) min_ansible_version: 1.2 defaults: --- # defaults file for kernel kernel_paramiters: kernel.panic: value: \"5\" # ignoreerrors: yes kernel.sem: value: \"5010 641280 5010 128\" kernel.shmmax: value: \"68719476736\" kernel.shmall: value: \"4294967296\" kernel.core_uses_pid: value: 1 kernel.sysrq: value: 0 kernel.pid_max: value: 4129024 kernel.threads-max: value: 1029751 kernel.shmmni: ... tasks: --- # tasks file for kernel - name: KERNEL | modify file_limits command: echo '* - nofile 10240' >> /etc/security/limits.conf;echo \"ulimit -n 10240\" >>/etc/profile tags: KERNEL - name: KERNEL | modify kernel paramiters sysctl: name=\" {{ item.key }} \" value=\" {{ item.value.value }} \" state=present reload=yes ignoreerrors=yes with_dict: kernel_paramiters tags: KERNEL 比如你有一个site.yml: --- - name: apply common configuration to all nodes hosts: - all remote_user: root gather_facts: True roles: #- { role: kernel } #- role: kernel - kernel 上边的三种形式都是可以的,使用下面的命令,即可完成kernel参数的调整. ansible-playbook -i xx.ivt site.yml","tags":"Ansible","title":"ansible 快速上手--role"},{"url":"ansible-kuai-su-shang-shou-loops.html","text":"Ansible提供了多种遍历操作功能,包括对特定文件等操作 with_items标准循环 - name: add several users user: name= {{ item }} state=present groups=wheel with_items: - testuser1 - testuser2 笛卡尔积 - hosts: all vars: - list1: [1,2,3] - list2: [4,5,6] - list3: [7,8,9] tasks: - debug: msg=\" {{ item }} \" with_cartesian: - list1 - list2 - list3 with_file --- - hosts: all tasks: # emit a debug message containing the content of each file. - debug: msg: \" {{ item }} \" with_file: - first_example_file - second_example_file with_dict --- users: alice: name: Alice Appleworth telephone: 123-456-7890 bob: name: Bob Bananarama telephone: 987-654-3210 tasks: - name: Print phone records debug: msg=\"User {{ item.key }} is {{ item.value.name }} ( {{ item.value.telephone }} )\" with_dict: \" {{ users }} \" nested - name: give users access to multiple databases mysql_user: name= {{ item [ 0 ] }} priv= {{ item [ 1 ] }} .*:ALL append_privs=yes password=foo with_nested: - [ 'alice', 'bob' ] - [ 'clientdb', 'employeedb', 'providerdb' ] new in 2.0:include yml: # main.yml - include: inner.yml with_items: - 1 - 2 - 3 # inner.yml - set_fact: outer_item: \" {{ item }} \" - debug: msg: \"outer item= {{ outer_item }} inner item= {{ item }} \" with_items: - a - b - c new in 2.2:循环间隔时间 # main.yml - name: create servers, pause 3s before creating next digital_ocean: name: \" {{ item }} \" state: present with_items: - server1 - server2 loop_control: pause: 3 new in 2.2:只显示部分到stdout - name: create servers digital_ocean: name: \" {{ item.name }} \" state: present with_items: - name: server1 disks: 3gb ram: 15Gb network: nic01: 100Gb nic02: 10Gb ... loop_control: label: \" {{ item.name }} \" loop_control :new in 2.1 # main.yml - include: inner.yml with_items: - 1 - 2 - 3 loop_control: loop_var: outer_item # inner.yml - debug: msg: \"outer item= {{ outer_item }} inner item= {{ item }} \" with_items: - a - b - c with_inventory_hostnames :new in 2.1 # show all the hosts in the inventory - debug: msg: \" {{ item }} \" with_inventory_hostnames: - all # show all the hosts matching the pattern, ie all but the group www - debug: msg: \" {{ item }} \" with_inventory_hostnames: - all:!www Flattening A List --- - hosts: all vars: packages_base: - [ 'foo-package', 'bar-package' ] packages_apps: - [ ['one-package', 'two-package' ]] - [ ['red-package'], ['blue-package']] tasks: - name: flattened loop demo debug: msg: \" {{ item }} \" with_flattened: - \" {{ packages_base }} \" - \" {{ packages_apps }} \" ini 文件 The ini plugin can use regexp to retrieve a set of keys. As a consequence, we can loop over this set. Here is the ini file we'll use: [section1] value1=section1/value1 value2=section1/value2 [section2] value1=section2/value1 value2=section2/value2 Here is an example of using with_ini: - debug: msg: \" {{ item }} \" with_ini: - value[1-2] - section: section1 - file: \"lookup.ini\" - re: true with_first_found - name: INTERFACES | Create Ansible header for /etc/network/interfaces template: src: \" {{ item }} \" dest: \"/etc/foo.conf\" with_first_found: - \" {{ ansible_virtualization_type }} _foo.conf\" - \"default_foo.conf\" ####################3 - name: some configuration template template: src: \" {{ item }} \" dest: \"/etc/file.cfg\" mode: 0444 owner: \"root\" group: \"root\" with_first_found: - files: - \" {{ inventory_hostname }} /etc/file.cfg\" paths: - ../../../templates.overwrites - ../../../templates - files: - etc/file.cfg paths: - templates with_sequence --- - hosts: all tasks: # create groups - group: name: \"evens\" state: present - group: name: \"odds\" state: present # create some test users - user: name: \" {{ item }} \" state: present groups: \"evens\" with_sequence: - start: 0 - end: 32 - format: testuser%02x # create a series of directories with even numbers for some reason - file: dest: \"/var/stuff/ {{ item }} \" state: directory with_sequence: - start: 4 - end: 16 - stride: 2 # a simpler way to use the sequence plugin # create 4 groups - group: name: \"group {{ item }} \" state: present with_sequence: count: 4 with_together #And you want the set of ‘(a, 1)' and ‘(b, 2)' and so on. Use ‘with_together' to get this: tasks: - debug: msg: \" {{ item.0 }} and {{ item.1 }} \" with_together: - \" {{ alpha }} \" - \" {{ numbers }} \" with_nested :后面接iteration,如果直接是dict()会只取keys();但如果是[dict()],没问题 - name: here, 'users' contains the above list of employees mysql_user: name: \" {{ item [ 0 ] }} \" priv: \" {{ item [ 1 ] }} .*:ALL\" append_privs: yes password: \"foo\" with_nested: - \" {{ users }} \" - [ 'clientdb', 'employeedb', 'providerdb' ] 遍历数据并行集合 --- - hosts: webservers remote_user: root vars: alpha: [ 'a','b','c','d'] numbers: [ 1,2,3,4 ] tasks: - debug: msg=\" {{ item.0 }} and {{ item.1 }} \" with_together: - \" {{ alpha }} \" - \" {{ numbers }} \" with_fileglob匹配单个目录下所有文件 --- - hosts: all tasks: # first ensure our target directory exists - file: dest=/etc/fooapp state=directory # copy each file over that matches the given pattern - copy: src= {{ item }} dest=/etc/fooapp/ owner=root mode=600 with_fileglob: - /playbooks/files/fooapp/* 也可以遍历嵌套的子列表： 变量文件 ： users: - name: alice authorized: - /tmp/alice/onekey.pub - /tmp/alice/twokey.pub mysql: password: mysql-password hosts: - \"%\" - \"127.0.0.1\" - \"::1\" - \"localhost\" privs: - \"*.*:SELECT\" - \"DB1.*:ALL\" - name: bob authorized: - /tmp/bob/id_rsa.pub mysql: password: other-mysql-password hosts: - \"db1\" privs: - \"*.*:SELECT\" - \"DB2.*:ALL\" - name: Setup MySQL users mysql_user: name= {{ item.0.user }} password= {{ item.0.mysql.password }} host= {{ item.1 }} priv= {{ item.0.mysql.privs | join ( '/' ) }} with_subelements: - users - mysql.hosts #must be string any_errors_fatal :The any_errors_fatal play option will mark all hosts as failed if any fails, causing an immediate abort: - hosts: somehosts any_errors_fatal: true roles: - myrole with_dict --- - hosts: all vars: users: alice: name: Alice Appleworth telephone: 123-456-7890 bob: name: Bob Bananarama telephone: 987-654-3210 tasks: - name: Print phone records debug: msg=\"User {{ item.key }} is {{ item.value.name }} ( {{ item.value.telephone }} )\" with_dict: \" {{ users }} \" #不能使用 #with_dict: # - aaa register 配合with_items - name: registered variable usage as a with_items list hosts: all tasks: - name: retrieve the list of home directories command: ls /home register: home_dirs - name: add home dirs to the backup spooler file: path=/mnt/bkspool/ {{ item }} src=/home/ {{ item }} state=link with_items: \" {{ home_dirs.stdout_lines }} \" # same as with_items: \" {{ home_dirs.stdout.split () }} \"","tags":"Ansible","title":"ansible 快速上手--loops"},{"url":"ansible-kuai-su-shang-shou-prompts.html","text":"prompt关键字能够实现交互式动态提供变量给playbook 常规用法 --- - hosts: all remote_user: root vars: from: \"camelot\" vars_prompt: - name: \"name\" prompt: \"what is your name?\" - name: \"quest\" prompt: \"what is your quest?\" - name: \"favcolor\" prompt: \"what is your favorite color?\" 使用 default: vars_prompt: - name: \"release_version\" prompt: \"Product release version\" default: \"1.0\" use private vars_prompt: - name: \"some_password\" prompt: \"Enter password\" private: yes - name: \"release_version\" prompt: \"Product release version\" private: no If Passlib is installed, vars_prompt can also crypt the entered value so you can use it, for instance, with the user module to define a password,You can use any crypt scheme supported by ‘Passlib': vars_prompt: - name: \"my_password2\" prompt: \"Enter password2\" private: yes encrypt: \"sha512_crypt\" confirm: yes salt_size: 7","tags":"Ansible","title":"ansible 快速上手--Prompts"},{"url":"ansible-kuai-su-shang-shou-strategy.html","text":"strategy 表明每个task在hosts中执行的相对顺序 主要有三种执行策略: linear 线性:每个task的执行在全部主机执行完成时再执行下一个 - hosts: \" {{ hosts }} \" gather_facts: yes strategy: linear tasks: - name: debug debug: var=ansible_kernel 执行结果: free :即每个主机的执行过程是连续的,不存在等待的情况 - hosts: \" {{ hosts }} \" gather_facts: yes strategy: free tasks: - name: sleep shell: sleep \" {{ 10 | random }} \"; - name: debug debug: var=ansible_kernel 执行结果: debug strategy:允许进入交互式（另外--step可以交互式执行tasks)，修正了相关问题后，继续执行，如： - hosts: test strategy: debug gather_facts: no vars: var1: value1 tasks: - name: wrong variable ping: data= {{ wrong_var }} 允许的命令： p task/vars/host/result task.args[key] = value vars[key] = value r(edo) c(ontinue) q(uit)","tags":"Ansible","title":"ansible 快速上手--strategy"},{"url":"ansible-kuai-su-shang-shou-conditionals.html","text":"条件关键字,极大地加强了逻辑严谨性，并且提升了功能的健壮性 when: 只有条件为真时该task才会执行 tasks: - shell: echo \"I've got ' {{ foo }} ' and am not afraid to use it!\" when: foo is defined - fail: msg=\"Bailing out. this play requires 'bar'\" when: bar is undefined or 用在roles和include - hosts: webservers roles: - { role: debian_stock_config, when: ansible_os_family == 'Debian' } - include: tasks/sometasks.yml when: \"'reticulating splines' in output\" changed_when:在task级别控制task的执行状态 During iteration, the result of the current item will be placed in the variable: - shell: echo \" {{ item }} \" with_items: - one - two register: echo changed_when: echo.stdout != \"one\" failed_when :自定义执行结果为失败 tasks: - name: Check if MySQL is already installed. stat: path=\" {{ mysql_basedir }} \" register: mysql_installed - name: set installstatus set_fact: installstatus: { rc: 0 } failed_when: not mysql_installed.stat.exists when 使用jinja2 filter: tasks: - command: /bin/false register: result ignore_errors: True - command: /bin/something when: result|failed - command: /bin/something_else when: result|succeeded - command: /bin/still/something_else when: result|skipped 使用default filter来对付未定义的变量： - command: echo {{ item }} with_items: \" {{ mylist | default ([]) }} \" when: item > 5","tags":"Ansible","title":"ansible 快速上手--Conditionals"},{"url":"ansiblekuai-su-shang-shou-kai-shi-shi-yong-playbook.html","text":"使用第一个playbook，最简单的形式 #modify_apache_config.yml --- - hosts: webservers vars: http_port: 80 max_clients: 200 remote_user: root tasks: - name: ensure apache is at the latest version yum: name=httpd state=latest - name: write the apache config file template: src=/srv/httpd.j2 dest=/etc/httpd.conf notify: - restart apache - name: ensure apache is running (and enable it at boot) service: name=httpd state=started enabled=yes handlers: - name: restart apache service: name=httpd state=restarted 先介绍下几个重要的ansible playbook的任务执行结果状态： changed： 操作成功，且对操作目标做出了修改 failed： 操作未成功。 skipped ：未执行该任务，因为状态已一致或根据条件设定而需要跳过。 对以上的playbook进行一下注解： hosts：目标主机（组），来自inventory，可以是组名、正则模式、单个IP、单个主机名等，这里是主机组名。 vars: 即变量的定义，这里变量是针对该play的。变量可以被引用，这里实际在模板httpd.j2中被引用，下面的测试demo将展示如何使用变量。 remote_user： 连接到ssh-server的系统用户，这里使用root tasks： 定义任务部分，可以有任意多个\"task\"，每个task完成一个动作，可以是安装完成某些软件、重启某个服务、修改某个文件等等。 这里的template/service均为所使用功能模块的名子，这与使用ansible命令行时，功能完全一致，详细的用法，还是 ansible-doc -l 来查看。比如service: name=xx state=xx,这里的name/state均是service模块所使用的参数。 notify/handler： 在task中可以出现notify关键字，它表示本task（这里指修改配置文件 ）结果是changed时，发出这个通知，通知的结果就是，之后定义的handler作出相应的动作，这里当配置有修改时，将会重启apache服务 可以使用ansilbe-playbook 命令执行这个playbook: ansible-playbook -i host.ivt modify_apache_config.yml playbook执行的特点是结果一致性（除了异常发生） 一个playbook,可以有多个play. 这将稍微复杂些，task的执行状态也可以通过register关键字来注册到变量，这个变量（更多细节参考 这里 )将是全局可用，配合条件判断语法，作出不同的动作处理 如果有兴趣，可以直接看我的这个dockerhost初始化剧本。 下面再来一个简单的demo: - hosts: - all vars: - list_tar: - mysql-connector - mysqldb - pip_tar_ball: pip-8.0.2.tar.gz tasks: - name: install_setuptools yum: name: python-setuptools state: present tags: install_setuptools - name: install_pip copy: src= {{ pip_tar_ball }} dest=/tmp/ {{ pip_tar_ball }} tags: install_pip - name: install_pip shell: easy_install /tmp/ {{ pip_tar_ball }} tags: install_pip - name: upgrade_pip shell: pip install --upgrade pip tags: upgrade_pip - name: install packages via pip pip: name: \" {{ item }} \" state: latest with_items: - \" {{ list_tar }} \" tags: install_packages 这个例子，出现了两个新的关键字： tags：就是标签，可以在ansible-playbook命令中使用--tags 来指定仅执行哪些任务 with_items: 最常用的循环处理结构，类似for循环，但通常来说，module都有优化，即不会多次发起ssh连接，而是批量处理，比如yum. item 即是当前的变量内容。 这里涉及了变量的使用：在ansible playbook中，变量应该严格以\"{{var}}\"(双引号）的形式来使用。 playbook的初体验就暂且先到这里。","tags":"Ansible","title":"ansible快速上手--开始使用playbook"},{"url":"ansible-kuai-su-shang-shou-dynamic-inventory.html","text":"Ansible支持 动态inventory : 下面是使用范例： 脚本需要执行权限: 1 2 3 4 5 6 #!/usr/bin/python import json , sys print json . dumps ( { 'test' :[ '127.0.0.1' ] } ) 当执行--list,脚本返回 { \"databases\" : { \"hosts\" : [ \"host1.example.com\", \"host2.example.com\" ], \"vars\" : { \"a\" : true } }, \"webservers\" : [ \"host2.example.com\", \"host3.example.com\" ], \"atlanta\" : { \"hosts\" : [ \"host1.example.com\", \"host4.example.com\", \"host5.example.com\" ], \"vars\" : { \"b\" : false }, \"children\": [ \"marietta\", \"5points\" ] }, \"marietta\" : [ \"host6.example.com\" ], \"5points\" : [ \"host7.example.com\" ] } 1.3以后,以下形式可以优化性能: { # results of inventory script as above go here # ... \"_meta\" : { \"hostvars\" : { \"moocow.example.com\" : { \"asdf\" : 1234 }, \"llama.example.com\" : { \"asdf\" : 5678 }, } } }","tags":"Ansible","title":"ansible 快速上手--dynamic inventory"},{"url":"ansible-kuai-su-shang-shou.html","text":"Ansible 真正也是最重要的使用场景，就是playbook，顾名思义，它会像剧本一样，完成你的任务。 Ansible的模块设计遵循 幂等性 的原则,在使用playbook的过程中，你将更清晰的体会到这一特点。 Ansible 的应用目标有如下（但不限于）几个场景： 自动化部署应用 自动化配置管理 * 自动化的持续交付 这里将分几个部分来介绍，方便快速理解ansible的原理及开始使用: ansible 基本使用 ansible 快速上手--dynamic inventory ansible 快速上手--yaml语法简介 ansible快速上手－－开始使用playbook ansible 快速上手--Conditionals ansible 快速上手--strategy ansible 快速上手--Prompts ansible 快速上手--loops ansible 快速上手--role","tags":"Ansible","title":"ansible 快速上手"},{"url":"ansible-kuai-su-shang-shou-yamlyu-fa-jian-jie.html","text":"假定您有某种编程语言的基础或至少了解数组、HASH结构。 yaml类似python语言，有严格的缩进要求，一般是两个空格作为缩进比例。 列表和字典 列表的所有元素均使用\"-\"打头例如: - Apple - Orange - Strawberry - Mango 字典通过key与valuef进行标识例如 : name : Example Developer job : Developer skill : Elite 或 {name: Example Developer, job: Developer, skill: Elite} ymal中的变量 在 yaml 中可以使用vars关键字来定义变量 ： vars : var_name : value 变量的引用 : - name: add several users vars: user1: testuser1 user2: testuser2 user: name= {{ user1 }} state=present groups=wheel user: name= {{ user2 }} state=present groups=wheel 使用迭代方式 : with_nested - name: give users access to multiple databases mysql_user: name= {{ item [ 0 ] }} priv= {{ item [ 1 ] }} .*:ALL append_privs=yes password=foo with_nested: - [ 'alice', 'bob' ] - [ 'clientdb', 'employeedb', 'providerdb' ] with_items - name: add several users user: name= {{ item }} state=present groups=wheel with_items: - testuser1 - testuser2 事实上with_items中可以使用元素还可为hashes例如 : - name: add several users user: name= {{ item.name }} state=present groups= {{ item.groups }} with_items: - { name: 'testuser1', groups: 'wheel' } - { name: 'testuser2', groups: 'root' } hash users : alice : name : Alice Appleworth telephone : 123 - 456 - 7890 bob : name : Bob Bananarama telephone : 987 - 654 - 3210 tasks : - name : Print phone records debug : msg = \"User {{ item.key }} is {{ item.value.name }} ({{ item.value.telephone }})\" with_dict : users Looping over Fileglobs - hosts: all tasks: # first ensure our target directory exists - file: dest=/etc/fooapp state=directory # copy each file over that matches the given pattern - copy: src= {{ item }} dest=/etc/fooapp/ owner=root mode=600 with_fileglob: - /playbooks/files/fooapp/*","tags":"Ansible","title":"ansible 快速上手--yaml语法简介"},{"url":"ansible-ji-ben-shi-yong.html","text":"简介 ansible是新出现的运维工具是基于Python研发的糅合了众多老牌运维工具的优点实现了批量操作系统配置、批量程序的部署、批量运行命令等功能。具有以下特点： agentless 模式：基于ssh服务实现工作在被监控端。监控端是ssh的客户端。 幂等性：不会重复执行相同的指令。例如不会重复安装软件 期望状态：只需要告诉被监控端的期望状态。 安装 pip install ansible 定义Host Inventory（主机清单） vim /etc/ansible/hosts，有以下几种可用形式: 带附属属性 [testgroup] 10.10.2.6 ansible_ssh_user=root 10.10.0.11 ansible_ssh_user=root [others] other1.example.com ansible_connection=ssh ansible_ssh_user=mpdehaan 使用pattern [webservers] www[01:50].example.com [databases] db-[a:f].example.com 针对group的vars [atlanta] host1 http_port = 80 maxRequestsPerChild=808 #host variables ,用在 playbooks. [atlanta] host1 host2 [atlanta:vars] ntp_server = ntp.atlanta.example.com proxy = proxy.atlanta.example.com 更大的组 ，组vars [atlanta] host1 host2 [raleigh] host2 host3 [southeast:children] atlanta raleigh [southeast:vars] some_server = foo.southeast.example.com halon_system_timeout = 30 self_destruct_countdown = 60 escape_pods = 2 [usa:children] southeast northeast southwest northwest 附可用属性列表 ansible_ssh_host The name of the host to connect to, if different from the alias you wish to give to it. ansible_ssh_port The ssh port number, if not 22 ansible_ssh_user The default ssh user name to use. ansible_ssh_pass The ssh password to use (this is insecure, we strongly recommend using --ask-pass or SSH keys) ansible_sudo The boolean to decide if sudo should be used for this host. Defaults to false. ansible_sudo_pass The sudo password to use (this is insecure, we strongly recommend using --ask-sudo-pass) ansible_sudo_exe (new in version 1.8) The sudo command path. ansible_connection Connection type of the host. Candidates are local, ssh or paramiko. The default is paramiko before Ansible 1.2, and 'smart' afterwards which detects whether usage of 'ssh' would be feasible based on whether ControlPersist is supported. ansible_ssh_private_key_file Private key file used by ssh. Useful if using multiple keys and you don't want to use SSH agent. ansible_shell_type The shell type of the target system. By default commands are formatted using 'sh'-style syntax by default. Setting this to 'csh' or 'fish' will cause commands executed on target systems to follow those shell's syntax instead. ansible_python_interpreter The target host python path. This is useful for systems with more than one Python or not located at \"/usr/bin/python\" such as \\*BSD, or where /usr/bin/python is not a 2.X series Python. We do not use the \"/usr/bin/env\" mechanism as that requires the remote user's path to be set right and also assumes the \"python\" executable is named python, where the executable might be named something like \"python26\". ansible_\\*_interpreter Works for anything such as ruby or perl and works just like ansible_python_interpreter. This replaces shebang of modules which will run on that host. 使用范例 最常用的用法 ansible <Host-partten> -m MOD -a 'args' 查看所有支持的模块： ansible-doc -l 查看某个模块的文档： ansible-doc yum 导入管理员KEY ansible 10.10.2.6 -m shell -a 'echo \"ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA5k2RQBtZOpgADIELw4mtBe61bOX09spz/Z+4yjQN/bR68FPyQXk2sQWEt8gWUx2SB3xNLOWe1LF2bpcaTPE5VLHsg1AORiwzTVNDvtMtLWo150t5QOYzvXUIPcPEgPgaMoMB4fJ5+xhIEwYwA6PJrFObsB/SWThIkXVZmaKtVRIywP1KZqyRpfXm3jzw1BL4iBW56HMorM+0Mq9tZTx/Cv+A8/aFzHInbQbC//rhJgV1k+v7DMdG5co6CExW/CuuDcbJOh8+jJdspT1GqocMMIIWhP56m1iqJv7DZqy7xrPiPUTy6M5Ri7qLAcCx3N+hZTf0tjtjbkQDm88sM82hUQ== 10.2.1.11\">>/home/admin/.ssh/authorized_keys' 或者 ansible -m 'copy' -a 'src=/root/.ssh/id_rsa.pub dest=/root' testgroup --ask-pass ansible -m 'shell' -a 'cat /root/id_rsa.pub >> .ssh/authorized_keys' testgroup --ask-pass 使用sudo ansible testgroup -m shell -a 'date' -u username(os user1) -U otheruser(sudo to user2) [--ask-sudo-pass] 使用yum: ansible -m 'yum' -a \"name=vsftpd state=present\" testgroup #确定已经安装，但不要更新它 ansible webservers -m yum -a \"name=acme-1.5 state=present\" #确定已经安装，版本是1.5 ansible webservers -m yum -a \"name=acme state=latest\" testgroup #安装到最新 ansible webservers -m yum -a \"name=acme state=absent\" #确认不要安装（移除） 管理用户 ansible all -m user -a \"name=foo password=<crypted password here>\" #新增或改密码 ansible all -m user -a \"name=foo state=absent\" #删除用户 使用service ansible -m 'service' -a 'name=vsftpd state=started enabled=yes' 10.10.2.6 #启动并chkconfig on ansible webservers -m service -a \"name=httpd state=restarted #重启 ansible webservers -m service -a \"name=httpd state=stopped\" #关闭 传送文件： ansible testgroup -m copy -a \"src=/etc/hosts dest=/tmp/hosts\" 修改文件属性： ansible *2.6 -m 'file' -a 'dest=/root/aaa mode=600 owner=admin group=wheel' 也能创建文件夹 ansible webservers -m file -a \"dest=/path/to/c mode=755 owner=mdehaan group=mdehaan state=directory\" 从git部署程序服务 ansible webservers -m git -a \"repo=git://foo.example.org/repo.git dest=/srv/myapp version=HEAD\"#Since Ansible modules can notify change handlers it is possible to tell Ansible to run specific tasks when the code is updated, such as deploying Perl/Python/PHP/Ruby directly from git and then restarting apache. 限定时间的后台执行： ansible all -B 3600 -P 0 -a \"/usr/bin/long_running_operation --do-stuff\" #最多执行60分钟，不检查执行状态 ansible web1.example.com -m async_status -a \"jid=488359678239.2844\" #使用async_status模块检查之前放后台的job id的执行状态。 ansible all -B 1800 -P 60 -a \"/usr/bin/long_running_operation --do-stuff\" #最多执行30分钟，60秒轮训检查执行状态一次。 #当-B 指定的时间耗尽，该远程执行的命令会被终止。注意copy模块不适用后台运行的模式。 #可以使用--forks指定并发的进程数，以快速在所有选定的目标机器启动job","tags":"Ansible","title":"ansible 基本使用"}]}